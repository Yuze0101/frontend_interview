# 浏览器
浏览器是前端的朋友，咱们前端干啥基本都得跟浏览器打交道（rn、flutter等跨平台项目，也约等于“浏览器”）。

开发浏览器是个不亚于开发一个操作系统的复杂项目，我们就挑前端需要知道的一些东西来讲。
## 浏览器的渲染流程
简单来讲，应该是以下步骤：
1. 创建dom树
2. 创建cssom树
3. dom树和cssom树结合生成渲染树
4. gpu绘制每一层级并叠加

这些不包含js部分，如果有js引入，改动了dom或者css，那将在创建dom树和cssom树之后，执行js，重新算出来的dom树和cssom树在进行结合。

在这之后，如果再有交互导致树结构变化，需要计算改变的dom树、cssom树部分，gpu做重绘。

很明显，这里面涉及了大量的计算，因为树结构的改变，都需要遍历到最深处看是否有变化，浏览器是多线程的app，他很快就完成了这些计算，但是再强大也有瓶颈。

### cpu瓶颈
计算dom树、cssom树会消耗大量的计算资源，所以我们需要尽可能的不要过多计算，现代的vue、react框架都在做这个事情，也就是避免重排，按需重绘。
#### 重排与重绘
什么时候能导致重排与重绘呢？很容易想到，是树结构改变的时候，那我们就尝试尽量**减少改变树结构**。

现代前端框架react、vue的核心，就是利用虚拟dom，减少对真实dom的改动次数，来减少树结构的改变。关于如何利用虚拟dom、响应式、react的fiber架构等等做优化，又是另一个篇章了。

如果是原生项目，尽量简单的层级结构，树节点尽量避免相互影响（如增删、修改大小等）

总之，最关键的就是 **减少改变树结构**。
### 内存瓶颈
这个一般不会拎出来说，对于现代浏览器和设备来讲，内存基本是够用的，前端开发一般也不会太关注内存，不过想做极限优化，还是要对内存做考量。

这部分，放到js的垃圾回收来讲。
## V8引擎
这玩意儿可太牛逼了，js跑的飞快全靠它。
网页app交互跑的快不快，跟他有极大关系。当然如果是其他平台，可能是内嵌的quickJs引擎，前端开发对这些黑魔法，都是膜拜就完事了。

javascript是单线程的，他简单，开发迅速，V8引擎JIT的加入（Just In Time），把js直接翻译为二进制字节码交给cpu执行，跑的飞快。

但是正因为javascript是单线程的，js的运行会阻碍UI线程（绘图线程），比如用最笨的方法找出100000以内的指数
```javascript
var count = 0;
for (i = 2; i < 100000; i++){
    for (j = 2; j < i; j++){
        if(i % j == 0){
            if(i != j) {
                break
            }else {
                console.log(i);
                count ++;
            }
        }
    }
}

```
haha～ 双循环榨干你的cpu，如果你浏览器在跑这个，你的button、什么交互都会失效了，因为他太慢啦，阻塞了UI线程，这也导致了感知卡顿。

类似的，如果有网络不佳阻塞js执行，硬盘读写阻塞js执行（一般不会），单线程就捉襟见肘了，所以引入了事件循环来解决这种问题。
### 事件循环
这个我认为是js的核心，事件循环机制不是js自己的东西，而是js环境为js准备的东西。
## GPU
绘制都会调用gpu，不论你是集成显卡还是独立显卡，甚至你cpu模拟的显卡（当然效果很差），绘图全靠它。

动画、字体、图片、任何你看到的东西，都是gpu绘制出来的，所以，如果app有大量的动画、css特效、有可能造成你gpu瓶颈（掉帧）。
比如 css3 的blur滤镜，叠加三四层层，一般gpu都撑不住了。