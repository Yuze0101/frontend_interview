# 浏览器
浏览器是前端的朋友，咱们前端干啥基本都得跟浏览器打交道（rn、flutter等跨平台项目，也约等于“浏览器”）。

开发浏览器是个不亚于开发一个操作系统的复杂项目，我们就挑前端需要知道的一些东西来讲。
## 浏览器的渲染流程
简单来讲，应该是以下步骤：
1. 创建dom树
2. 创建cssom树
3. dom树和cssom树结合生成渲染树
4. gpu绘制每一层级并叠加

这些不包含js部分，如果有js引入，改动了dom或者css，那将在创建dom树和cssom树之后，执行js，重新算出来的dom树和cssom树在进行结合。

在这之后，如果再有交互导致树结构变化，需要计算改变的dom树、cssom树部分，gpu做重绘。

很明显，这里面涉及了大量的计算，因为树结构的改变，都需要遍历到最深处看是否有变化，浏览器是多线程的app，他很快就完成了这些计算，但是再强大也有瓶颈。

### cpu瓶颈
计算dom树、cssom树会消耗大量的计算资源，所以我们需要尽可能的不要过多计算，现代的vue、react框架都在做这个事情，也就是避免重排，按需重绘。
#### 重排与重绘
什么时候能导致重排与重绘呢？很容易想到，是树结构改变的时候，那我们就尝试尽量**减少改变树结构**。

现代前端框架react、vue的核心，就是利用虚拟dom，减少对真实dom的改动次数，来减少树结构的改变。关于如何利用虚拟dom、响应式、react的fiber架构等等做优化，又是另一个篇章了。

如果是原生项目，尽量简单的层级结构，树节点尽量避免相互影响（如增删、修改大小等）

总之，最关键的就是 **减少改变树结构**。
### 内存瓶颈
这个一般不会拎出来说，对于现代浏览器和设备来讲，内存基本是够用的，前端开发一般也不会太关注内存，不过想做极限优化，还是要对内存做考量。

这部分，放到js的垃圾回收来讲。
## V8引擎
这玩意儿可太牛逼了，js跑的飞快全靠它。
网页app交互跑的快不快，跟他有极大关系。当然如果是其他平台，可能是内嵌的quickJs引擎，前端开发对这些黑魔法，都是膜拜就完事了。

javascript是单线程的，他简单，开发迅速，V8引擎JIT的加入（Just In Time），把js直接翻译为二进制字节码交给cpu执行，跑的飞快。

但是正因为javascript是单线程的，js的运行会阻碍UI线程（绘图线程），比如用最笨的方法找出100000以内的指数
```javascript
var count = 0;
for (i = 2; i < 100000; i++){
    for (j = 2; j < i; j++){
        if(i % j == 0){
            if(i != j) {
                break
            }else {
                console.log(i);
                count ++;
            }
        }
    }
}

```
haha～ 双循环榨干你的cpu，如果你浏览器在跑这个，你的button、什么交互都会失效了，因为他太慢啦，阻塞了UI线程，这也导致了感知卡顿。

类似的，如果有网络不佳阻塞js执行，硬盘读写阻塞js执行（一般不会），单线程就捉襟见肘了，所以引入了事件循环来解决这种问题。
### 事件循环
这个我认为是js的核心，为了理解事件循环，我们得站在更高的纬度（多线程）去理解他。

想象一下你是一个机器人，你手里有个纸条，你只能依次按照这个纸条上写的事情去做。假设你看到了纸条上写：“5分钟之后唱首歌”，你开始了等待，这五分钟什么都没干，在外人看来，你就和坏了没什么两样。

这看起来很笨。

怎么办呢，你想到如果有另一个机器人，可以帮你把这条指令保管起来，五分钟之后告诉你：“嗨，你该唱歌了。”，你这五分钟就不用一直等待，就可以先干别的了。

于是乎，你拿到“5分钟之后唱首歌”指令，你交给了另一个机器人，那个机器人说：“ok”，你知道递交这个动作完毕了， 你接着去跑纸条的其他指令了。

在这里，js就是那个单线程的你，纸条就是事件循环的模型，另外一个机器人，就是给js环境注入的“魔法”了，浏览器会帮你先拿着唱歌的指令，然后同步告诉你你这个指令结束了，可以先干别的，到时候叫你。

结论：js不堵塞还能异步的操作，都是有其他“黑魔法”帮他实现的，也就是凌驾于js之上的东西。

其实类比浏览器的js和node的js，就会发现，浏览器的js有window对象，node的没有，他们的“root”上挂了不同的东西，这些并不是原生js有的，都是其底层为js增加的。

假设你用c或着rust实现了一个js运行时，你想为js实现setTimeout计时器，也是需要在c或者rust等底层为其实现api，注入到js内才可以。

所以不必纠结，js本身就是事件驱动的，你的交互一步步把js执行命令按顺序排好执行，遇到异步的交给浏览器说等等异步执行好了叫他继续，当然也可以等待异步来执行。

好像有点跑题，不过，我们只要合理利用事件循环，就能组织出来不阻塞UI进程、合理等待执行的操作，来给用户带来流畅丝滑的体验。
## GPU
绘制都会调用gpu，不论你是集成显卡还是独立显卡，甚至你cpu模拟的显卡（当然效果很差），绘图全靠它。

动画、字体、图片、任何你看到的东西，都是gpu绘制出来的，所以，如果app有大量的动画、css特效、有可能造成你gpu瓶颈（掉帧）。
比如 css3 的blur滤镜，叠加三四层层，一般gpu都撑不住了。

gpu绘制是很复杂的东西，专业性很强，我目前了解甚少QAQ